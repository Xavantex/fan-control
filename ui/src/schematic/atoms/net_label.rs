//! net name
//!
//!
//!

// every strongly separated net graph should be assigned one NetLabel on checking ... ?
// or: every net seg holds a Rc<NetLabel>, the same underlying NetLabel if connected
// how to handle multiple user defined within a connected graph? should highlight segments

// maybe just do what cadence does

use std::{cell::RefCell, hash::Hasher, rc::Rc};

use crate::schematic::SchematicAtom;
use crate::transforms::SSPoint;
use crate::Drawable;
use crate::{
    schematic::interactable::{Interactable, Interactive},
    transforms::{
        sst_to_vvt, vvt_to_sst, Point, SSTransform, VCTransform, VSBox, VSPoint, VSVec, VVTransform,
    },
};
use iced::{
    widget::canvas::{self, Frame, Text},
    Color, Size,
};

use by_address::ByAddress;

/// net label, which can be user set
#[derive(Debug, Clone)]
pub struct NetLabel {
    /// net label
    name: String,

    /// label interactable
    pub interactable: Interactable,
    /// label transform - determines the posisiton and orientation of the label in schematic space
    transform: SSTransform,
    /// interactive bounds before transform
    bounds: VSBox,
}

impl Default for NetLabel {
    fn default() -> Self {
        NetLabel {
            name: String::from("default"),
            interactable: Interactable {
                bounds: VSBox::from_points([
                    VSPoint::origin() - VSVec::new(0.5, 0.5),
                    VSPoint::origin() + VSVec::new(0.5, 0.5),
                ]),
            },
            transform: SSTransform::identity(),
            bounds: VSBox::from_points([
                VSPoint::origin() - VSVec::new(0.5, 0.5),
                VSPoint::origin() + VSVec::new(0.5, 0.5),
            ]),
        }
    }
}

impl NetLabel {
    /// return the user defined net name if it is set, otherwise return the autogenerated net label
    pub fn read(&self) -> &str {
        &self.name
    }

    /// set the user defiend net name
    pub fn set_name(&mut self, newlabel: String) {
        self.name = newlabel;
    }

    /// returns the composite of the device's transform and the given vct
    fn compose_transform(&self, vct: VCTransform) -> VCTransform {
        sst_to_vvt(self.transform).then(&vct)
    }

    pub fn pos(&self) -> SSPoint {
        self.transform.transform_point(SSPoint::origin())
    }
}

impl Drawable for NetLabel {
    fn draw_persistent(&self, vct: VCTransform, vcscale: f32, frame: &mut Frame) {
        let vct_c = self.compose_transform(vct);
        let a = Text {
            content: self.name.clone(),
            position: Point::from(vct_c.transform_point(VSPoint::origin())).into(),
            color: Color::from_rgb(1.0, 1.0, 1.0),
            size: vcscale,
            ..Default::default()
        };
        frame.fill_text(a);

        let f = canvas::Fill {
            style: canvas::Style::Solid(Color::from_rgba(1.0, 1.0, 1.0, 0.5)),
            ..canvas::Fill::default()
        };
        let dim = 0.25;
        let ssb = VSBox::new(
            VSPoint::origin() - VSVec::new(dim / 2.0, dim / 2.0),
            VSPoint::origin() + VSVec::new(dim / 2.0, dim / 2.0),
        );

        let csbox = vct_c.outer_transformed_box(&ssb);

        let top_left = csbox.min;
        let size = Size::new(csbox.width(), csbox.height());
        frame.fill_rectangle(Point::from(top_left).into(), size, f);
    }

    fn draw_selected(&self, vct: VCTransform, vcscale: f32, frame: &mut Frame) {
        let vct_c = self.compose_transform(vct);
        let a = Text {
            content: self.name.clone(),
            position: Point::from(vct_c.transform_point(VSPoint::origin())).into(),
            color: Color::from_rgb(1.0, 0.8, 0.0),
            size: vcscale,
            ..Default::default()
        };
        frame.fill_text(a);

        let f = canvas::Fill {
            style: canvas::Style::Solid(Color::from_rgba(1.0, 0.8, 0.0, 0.5)),
            ..canvas::Fill::default()
        };
        let dim = 0.25;
        let ssb = VSBox::new(
            VSPoint::origin() - VSVec::new(dim / 2.0, dim / 2.0),
            VSPoint::origin() + VSVec::new(dim / 2.0, dim / 2.0),
        );

        let csbox = vct_c.outer_transformed_box(&ssb);

        let top_left = csbox.min;
        let size = Size::new(csbox.width(), csbox.height());
        frame.fill_rectangle(Point::from(top_left).into(), size, f);
    }

    fn draw_preview(&self, vct: VCTransform, vcscale: f32, frame: &mut Frame) {
        let vct_c = self.compose_transform(vct);
        let a = Text {
            content: self.name.clone(),
            position: Point::from(vct_c.transform_point(VSPoint::origin())).into(),
            color: Color::from_rgb(1.0, 1.0, 0.5),
            size: vcscale,
            ..Default::default()
        };
        frame.fill_text(a);

        let f = canvas::Fill {
            style: canvas::Style::Solid(Color::from_rgba(1.0, 1.0, 0.5, 0.5)),
            ..canvas::Fill::default()
        };
        let dim = 0.25;
        let ssb = VSBox::new(
            VSPoint::origin() - VSVec::new(dim / 2.0, dim / 2.0),
            VSPoint::origin() + VSVec::new(dim / 2.0, dim / 2.0),
        );

        let csbox = vct_c.outer_transformed_box(&ssb);

        let top_left = csbox.min;
        let size = Size::new(csbox.width(), csbox.height());
        frame.fill_rectangle(Point::from(top_left).into(), size, f);
    }
}

impl Interactive for NetLabel {
    fn transform(&mut self, vvt: VVTransform) {
        let sst = vvt_to_sst(vvt);
        self.transform = self.transform.then(&sst);
        self.interactable.bounds = sst_to_vvt(self.transform).outer_transformed_box(&self.bounds);
    }
}

/// newtype wrapper for `Rc<RefCell<NetLabel>>`. Hashes by memory address.
#[derive(Debug, Default, Clone)]
pub struct RcRLabel(pub Rc<RefCell<NetLabel>>);
impl PartialEq for RcRLabel {
    fn eq(&self, other: &Self) -> bool {
        ByAddress(self.0.clone()) == ByAddress(other.0.clone())
    }
}
impl Eq for RcRLabel {}
impl std::hash::Hash for RcRLabel {
    fn hash<H: Hasher>(&self, state: &mut H) {
        ByAddress(self.0.clone()).hash(state);
    }
}

impl Drawable for RcRLabel {
    fn draw_persistent(&self, vct: VCTransform, vcscale: f32, frame: &mut Frame) {
        self.0.borrow().draw_persistent(vct, vcscale, frame);
    }

    fn draw_selected(&self, vct: VCTransform, vcscale: f32, frame: &mut Frame) {
        self.0.borrow().draw_selected(vct, vcscale, frame);
    }

    fn draw_preview(&self, vct: VCTransform, vcscale: f32, frame: &mut Frame) {
        self.0.borrow().draw_preview(vct, vcscale, frame);
    }
}

impl SchematicAtom for RcRLabel {
    fn contains_vsp(&self, vsp: VSPoint) -> bool {
        self.0.borrow().interactable.contains_vsp(vsp)
    }
    fn bounding_box(&self) -> crate::transforms::VSBox {
        self.0.borrow().interactable.bounds
    }
}
